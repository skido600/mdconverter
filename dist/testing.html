<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>testing</title>
    <link rel="stylesheet" href="./style.css" />
  </head>
  <body>
    <div class="container">
      <a href="../index.html">‚Üê Back to all blogs</a>
      
      <link
        rel="stylesheet"
        href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css"
      />
      <hr>
<h2>layout: post
title: &quot;Builder design pattern in TypeScript&quot;
date: 2024-02-28 22:34:02 +0100
categories: design-patterns typescript</h2>
<p>The builder pattern allows to easily create complex objects with different configurable properties.
I&#39;d argue that there are better alternatives to create class instances in TypeScript. I&#39;ll present a few different approaches to use classes in TypeScript and give my opinions on them.</p>
<p>Let&#39;s start with a basic class:</p>
<pre><code class="language-typescript">// 1st example: basic class
class Car {
  private color: string;
  private weight: number;
  private price: number;
  private brand: string;
  private productionYear: number;

  constructor(
    weight: number,
    price: number,
    brand: string,
    productionYear: number,
    color: string = &quot;red&quot;
  ) {
    this.weight = weight;
    this.price = price;
    this.brand = brand;
    this.productionYear = productionYear;
    this.color = color;
  }

  public getWeight() {
    return this.weight;
  }

  public getPrice() {
    return this.price;
  }

  public getBrand() {
    return this.brand;
  }

  public getProductionYear() {
    return this.productionYear;
  }

  public getColor() {
    return this.color;
  }
}

const car = new Car(2_000, 50_000, &quot;Ford&quot;, 2013);
</code></pre>
<p>This code is a bit lenghty given its simplicity. Let&#39;s make it shorter using <a href="https://www.typescriptlang.org/docs/handbook/2/classes.html#parameter-properties">parameter properties</a> syntax available in TypeScript.</p>
<pre><code class="language-typescript">// 2nd example: class with parameter properties
class Car {
  constructor(
    private weight: number,
    private price: number,
    private brand: string,
    private productionYear: number,
    private color: string = &quot;red&quot;
  ) {}

  public getWeight() {
    return this.weight;
  }

  public getPrice() {
    return this.price;
  }

  public getBrand() {
    return this.brand;
  }

  public getProductionYear() {
    return this.productionYear;
  }

  public getColor() {
    return this.color;
  }
}

const car = new Car(2_000, 50_000, &quot;Ford&quot;, 2013);
</code></pre>
<p>The next problem that we have is that there are a lot of parameters in the constructor, which is hard to read. Let&#39;s fix that.</p>
<pre><code class="language-typescript">// 3rd example: class with all parameters packed into a single object
class Car {
  private color: string;
  private weight: number;
  private price: number;
  private brand: string;
  private productionYear: number;

  constructor({
    color = &quot;red&quot;,
    weight,
    price,
    brand,
    productionYear,
  }: {
    color?: string;
    weight: number;
    price: number;
    brand: string;
    productionYear: number;
  }) {
    this.color = color;
    this.weight = weight;
    this.price = price;
    this.brand = brand;
    this.productionYear = productionYear;
  }

  public getWeight() {
    return this.weight;
  }

  public getPrice() {
    return this.price;
  }

  public getBrand() {
    return this.brand;
  }

  public getProductionYear() {
    return this.productionYear;
  }

  public getColor() {
    return this.color;
  }
}

const car = new Car({
  weight: 2_000,
  price: 50_000,
  brand: &quot;Ford&quot;,
  productionYear: 2013,
});
</code></pre>
<p>The code has become lengthy again, but now the code for creating a new car is very readable. We can now also provide the parameters in any order we want which can be very handy.</p>
<pre><code class="language-typescript">// this also works:
const car = new Car({
  brand: &quot;Ford&quot;,
  weight: 2_000,
  productionYear: 2013,
  price: 50_000,
});
</code></pre>
<p>Let&#39;s now introduce one variation of the builder pattern. The builder pattern typically uses 2 separate classes: a builder class
and a base class. The builder class is usually a class with methods for adjusting the properties of the built object and a method for building the object.</p>
<pre><code class="language-typescript">// 4th approach: builder class + class with parameter properties
class CarBuilder {
  private color?: string;
  private weight?: number;
  private price?: number;
  private brand?: string;
  private productionYear?: number;

  public setColor(color: string) {
    this.color = color;
    return this;
  }

  public setWeight(weight: number) {
    this.weight = weight;
    return this;
  }

  public setPrice(price: number) {
    this.price = price;
    return this;
  }

  public setBrand(brand: string) {
    this.brand = brand;
    return this;
  }

  public setProductionYear(productionYear: number) {
    this.productionYear = productionYear;
    return this;
  }

  public build() {
    if (this.weight === undefined)
      throw new Error(&quot;The weight parameter is required&quot;);
    if (this.price === undefined)
      throw new Error(&quot;The price parameter is required&quot;);
    if (this.brand === undefined)
      throw new Error(&quot;The brand parameter is required&quot;);
    if (this.productionYear === undefined)
      throw new Error(&quot;The productionYear parameter is required&quot;);

    return new Car(
      this.weight,
      this.price,
      this.brand,
      this.productionYear,
      this.color
    );
  }
}

// the exact same class from 2nd example:
class Car {
  constructor(
    private weight: number,
    private price: number,
    private brand: string,
    private productionYear: number,
    private color: string = &quot;red&quot;
  ) {}

  public getWeight() {
    return this.weight;
  }

  public getPrice() {
    return this.price;
  }

  public getBrand() {
    return this.brand;
  }

  public getProductionYear() {
    return this.productionYear;
  }

  public getColor() {
    return this.color;
  }
}

const carBuilder = new CarBuilder();
const car = carBuilder
  .setWeight(2_000)
  .setBrand(&quot;Ford&quot;)
  .setPrice(50_000)
  .setProductionYear(2013)
  .build();

console.log(car.getColor()); // red
</code></pre>
<p>The builder pattern typically uses method chaining which you might know from algorithms operating on arrays or strings.</p>
<pre><code class="language-typescript">const client = clients
  .filter((client) =&gt; client.age &gt;= 18)
  .sort((prev, next) =&gt; prev.name.localeCompare(next.name))
  .find((client) =&gt; client.country === &quot;Poland&quot;);

const result = originalString
  .trim() // Remove leading and trailing whitespaces
  .toLowerCase() // Convert the string to lowercase
  .replace(&quot;,&quot;, &quot;&quot;) // Remove commas
  .substring(0, 5); // Get the first 5 characters of the string
</code></pre>
<h4>Method chaining</h4>
<p>Both <code>Array.prototype.filter</code> and <code>Array.prototype.sort</code> return arrays, allowing for an indefinite chaining of array methods. Similarly, builder setters return an instance of a builder, allowing for an indefinite chaining of builder setters. Setter chaining is optional - the <code>return this</code> statement can be omitted and the builder can be accessed in such manner:</p>
<pre><code class="language-typescript">carBuilder.setWeight(2_000);
carBuilder.setBrand(&quot;Ford&quot;);
carBuilder.setPrice(50_000);
carBuilder.setProductionYear(2013);
const car = carBuilder.build();
</code></pre>
<h2>Conclusions</h2>
<p>The builder pattern might be useful in Java code, but it doesn&#39;t seem to be that useful in TypeScript code - it requires creating an additional class, preferably with additional error checking (which works only in runtime and won&#39;t show any errors during compilation time).
I recommend using approaches from 2nd or 3rd examples instead (which one you&#39;d rather use will likely depend on number of constructor parameters).</p>
<h3>Extra notes</h3>
<ul>
<li><code>public</code> keyword is optional, I&#39;ve added it to make the examples more understandable for developers with less TypeScript experience.</li>
<li>getters can be created using <code>get</code> keyword (they are accessed a bit differently though).</li>
</ul>

      <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
      <script>hljs.highlightAll();</script>
      
    </div>
  </body>
</html>
